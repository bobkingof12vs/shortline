    <script src="../sources/threejs/build/three.min.js"></script>
    <script src="../sources/threejs/examples/js/controls/OrbitControls.js"></script>
    <script src="../sources/threejs/examples/fonts/helvetiker_regular.typeface.js"></script>
    <script src="../js/general.js"></script>
<script>
	
var trackPoints = [
	{p1: new THREE.Vector3(-50,  0,-50),
	 p2: new THREE.Vector3(-50,  0,  0),
	 p3: new THREE.Vector3(-50,  0, 50)
	},
	{p1: new THREE.Vector3(50,  0,-50),
	 p2: new THREE.Vector3(50,  0,-150),
	 p3: new THREE.Vector3(50,  0,-250)
	},
	{p1: new THREE.Vector3(-50,  0, 50),
	 p2: new THREE.Vector3(  0,  0, 50),
	 p3: new THREE.Vector3( 50,  0, 50)
	},
	{p1: new THREE.Vector3( 50,  0, 50),
	 p2: new THREE.Vector3( 50,  0,  0),
	 p3: new THREE.Vector3( 50,  0,-50)
	},
	{p1: new THREE.Vector3( -50,  0,-50),
	 p2: new THREE.Vector3(-100,  0,-50),
	 p3: new THREE.Vector3(-150,  0,-50)
	},
	{p1: new THREE.Vector3(-150,  0,-50),
	 p2: new THREE.Vector3(-200,  0,-50),
	 p3: new THREE.Vector3(-250,  0,-50)
	},
	{p1: new THREE.Vector3(-250,  0,-50),
	 p2: new THREE.Vector3(-300,  0,-50),
	 p3: new THREE.Vector3(-350,  0,-50)
	},
	{p1: new THREE.Vector3(-150,  0,-50),
	 p2: new THREE.Vector3(-150,  0,-100),
	 p3: new THREE.Vector3(-150,  0,-150)
	},
	{p1: new THREE.Vector3(-150,  0,-150),
	 p2: new THREE.Vector3(-150,  0,-200),
	 p3: new THREE.Vector3(-150,  0,-250)
	}
];

track = {
	ends: [],
	points: [],
	sections: [],
	switches: [],
	findMatchInTrackPoints: function(p1){
		var j = this.points.length;
		var count = [];
		while (j > 0){
			j--;
			if (equalXZ(p1, this.points[j].p1) == 1 | equalXZ(p1, this.points[j].p3) == 1) {
				count.push(j);
			}
		}
		return count;
	},
	addToSection: function(p1,p2,p3){
		
		function newSec(p1,p2,p3,segId){
			this.section.push({
				points:[p1,p2,p3],
				end: [{
					type: '',
					num: -1,
					getPoint: function(){return points[0];},
					setTypeNum: function(type,num){
						this.type = type;
						this.num = num;
					}
				},{
					type: '',
					num: -1,
					getPoint: function(){return points[points.length - 1];},
					setTypeNum: function(type,num){
						this.type = type;
						this.num = num;
					}
				}],
				segmentIds: [segId],
				hasSegment: function(segId){return segmentIds.indexof(segId);}
			});
			return this.section.length - 1;
		}
		
		function connectTo(p1,p2,p3,segId){
			secId = findSegInSec(segId);
			if(equalXZ(this.sections[secId].ends[0].getPoint(), p1) == 1){
				this.sections[secId].points.unshift(p3,p2);
			}
			else{
				this.sections[secId].points.push(p2,p3);
			}
			return secId;
		}
		
		function combineSecs(p1,p2,p3,seg1,seg2) {
			secId1 = findSegInSec(segId);
			secId2 = findSegInSec(segId);
			if(equalXZ(this.sections[secId1].ends[0].getPoint(), p1) == 1){
				this.sections[secId].points.unshift(p3,p2);
			}
			else{
				this.sections[secId].points.push(p2,p3);
			}
			
			if(equalXZ(this.sections[secId1].ends[0].getPoint()) == 1, equalXZ(this.sections[secId2].ends[0].getPoint()) == 1){
				this.sections[secId1].points.reverse();
				this.sections[secId1].ends[0] = this.sections[secId1].ends[1];
				this.sections[secId1].ends[1] = this.sections[secId2].ends[1];
			}
			else if(equalXZ(this.sections[secId1].ends[0].getPoint()) == 1, equalXZ(this.sections[secId2].ends[1].getPoint()) == 1){
				this.sections[secId1].points.reverse();
				this.sections[secId2].points.reverse();
				this.sections[secId1].ends[0] = this.sections[secId1].ends[1];
				this.sections[secId1].ends[1] = this.sections[secId2].ends[0];
			}
			else if(equalXZ(this.sections[secId1].ends[1].getPoint()) == 1, equalXZ(this.sections[secId2].ends[1].getPoint()) == 1){
				this.sections[secId1].ends[0] = this.sections[secId1].ends[0];
				this.sections[secId1].ends[1] = this.sections[secId2].ends[1];
			}
			else if(equalXZ(this.sections[secId1].ends[1].getPoint()) == 1, equalXZ(this.sections[secId2].ends[1].getPoint()) == 1){
				this.sections[secId2].points.reverse();
				this.sections[secId1].ends[0] = this.sections[secId1].ends[0];
				this.sections[secId1].ends[1] = this.sections[secId2].ends[0];
			}
			
			this.sections[secId1].points.pop();
			this.sections[secId1].points.concat(this.sections[secId2].points);
			this.sections[secId2] = null;
			
			return secId1;
		}
		
		function newEnd(newPoint, secId){
			if (oldPoint != undefined) {
				var i = this.ends.length;
				while (i > 0) {
					i--;
					if (this.ends[i].secId == secId) {
						this.ends[i].point = newPoint;
					}
				}
			}
			else{
				this.ends.push({
					point: newPoint,
					secId: secId 
				});
				if(equalXZ(this.section.end[0].getPoint(), newPoint) == 1){
					this.section.end[0].setTypeNum('end',this.ends.length - 1)
				}
			}
		}
		
		function removeEnd(point){
			var i = this.ends.length;
			while (i > 0) {
				i--;
				if (equalXZ(point,this.ends[i].point) == 1) {
					this.ends[i] = null;
				}
			}
		}
		
		function newSwitch() {
			
		}
		
		function addToSwitch() {
			
		}
		
		function findSegInSec(segId){
			var i = this.sections.length;
			while(i > 0){
				i--;
				if (this.sections[i].hasSection(segId) != -1) {
					return i;
				}
			}
			return false;
		}
		
		PointsP1 = this.findMatchInTrackPoints(p1);
		PointsP3 = this.findMatchInTrackPoints(p3);
		if (PointsP1.length == 0) {
			//point connects to nothing thus a new section
			if (PointsP3.length == 0) {
				//point connects to nothing thus a new new section
				newSec(p1,p2,p3);
				newEnd(p1);//add appropriate segid
				newEnd(p3);//add appropriate segid
			}
			else if (PointsP3.length == 1) {
				//point connects to an existing end
				//and is a new end
				connectTo(thatSeg,p3,p2,p1);
				removeEnd(p3);
				newEnd(p1);
			}
			else if (PointsP3.length == 2) {
				//point is a new switch
				//and is a new end
				newSec(p3,p2,p1);
				newSwitch(p3); //check for new segs
				newEnd(p1);//add appropriate segid
			}
			else if (PointsP3.length >= 3) {
				//point connects to existing switch
				//and is a new end
				newSec(p1,p2,p3);
				addToSwitch(thatSwitch,p3);//add appropriate segid
				newEnd(p1);//add appropriate segid
			}
		}
		else if (PointsP1.length == 1) {
			//point connects to an existing end
			if (PointsP3.length == 0) {
				//and is a new end
				connectTo(thatSeg,p3,p2,p1);
				removeEnd(p1);//add appropriate segid
			}
			else if (PointsP3.length == 1) {
				//point connects to two existing ends
				combineSecs(thatSeg,thisSeg);
				removeEnd(p1);//add appropriate segid
				removeEnd(p3);//add appropriate segid
			}
			else if (PointsP3.length == 2) {
				//point connects existing segement to a new switch
				connectTo(thatSeg,p3,p2,p1);
				removeEnd(p1);//add appropriate segid
				newSwitch(p3);//add appropriate segid
			}
			else if (PointsP3.length >= 3) {
				//point connects exitsting segment to existing switch
				connectTo(thatSeg,p3,p2,p1);
				removeEnd(p1);//add appropriate segid
				addToSwitch(thatSwitch,p3);//add appropriate segid
			}
		}
		else if (PointsP1.length == 2) {
			//point is a new switch
			if (PointsP3.length == 0) {
				//and is a new segment and a new end
				newSec(p1,p2,p3);
				newSwitch(p3);//add appropriate segid
				newEnd(p3);//add appropriate segid
			}
			else if (PointsP3.length == 1) {
				//point connects existing segement to a new switch
				newSwitch(p3);
				connectTo(thatSeg,p3,p2,p1);
				removeEnd(p3);
			}
			else if (PointsP3.length == 2) {
				//point connects new switch to a new switch
				newSec(p1,p2,p3);
				newSwitch(p1);
				newSwitch(p3);
			}
			else if (PointsP3.length >= 3) {
				//point connects an existing switch to existing switch
				newSec(p1,p2,p3);
				newSwitch(p1);
				addToSwitch(p3);
			}
		}
		else if (PointsP1.length >= 3) {
			//point connects to existing switch
			if (PointsP3.length == 0) {
				//and is a new segment and a new end
				newSec(p1,p2,p3);
				addToSwitch(p1);
				newEnd(p3);
			}
			else if (PointsP3.length == 1) {
				//point connects and existing switch to an existing end
				addToSwitch(p1);
				connectTo(thatSeg,p1,p2,p3);
				removeEnd(p3);
			}
			else if (PointsP3.length == 2) {
				//point connects new switch to an existing switch
				newSec(p1,p2,p3);
				newSwitch(p3);
				addToSwitch(p1);
			}
			else if (PointsP3.length >= 3) {
				//point connects an existing switch to existing switch
				newSec(p1,p2,p3);
				addToSwitch(p1);
				addToSwitch(p3);
			}
		}
		
		this.points.push({p1: p1,p2: p2,p3: p3});
		
	},
	addGroupToSection: function(thatGroup){
		
	},
	downloadData: function(){
		//ajax
		//if newData
		//add via group
	}
}
	/*
	
	
	function findMatchIn(arr, p1){
		var j = arr.length;
		var count = 0;
		while (j > 0){
			j--;
			if (equalXZ(p1, arr[j]) == 1) {
				return false;
			}
		}
		return true;
	}
	
	function findSegmentInSection(num){
		var k = trackSections.length;
		while (k > 0) {
			k--;
			if(trackSections[k].trackPointIds.indexOf(num) >= 0){
				return k;
			}
		}
		return false;
	}
	
	function buildASectionFromSegment(seg, dir){
		var retSeg = [];
		if (dir == 1) {
			retSeg[0] = trackPoints[seg].p1;
			retSeg[1] = trackPoints[seg].p2;
			retSeg[2] = trackPoints[seg].p3;
		}
		else{
			retSeg[0] = trackPoints[seg].p3;
			retSeg[1] = trackPoints[seg].p2;
			retSeg[2] = trackPoints[seg].p1;
		}
		retSegIds = [seg];
		while(findMatchIn(switches, retSeg[retSeg.length - 1]) && findMatchIn(ends, retSeg[retSeg.length - 1])){
			var k = trackPoints.length;
			while(k > 0){
				k--;
				if (equalXZ(trackPoints[k].p1, retSeg[retSeg.length - 1]) == 1 && k != retSegIds[retSegIds.length - 1]) {
					retSeg.push(trackPoints[k].p2,trackPoints[k].p3);
					retSegIds.push(k);
					break;
				}
				else if (equalXZ(trackPoints[k].p3, retSeg[retSeg.length - 1]) == 1 && k != retSegIds[retSegIds.length - 1]) {
					retSeg.push(trackPoints[k].p2,trackPoints[k].p1);
					retSegIds.push(k);
					break;
				}
			}
		}
		console.log({points: retSeg, trackPointIds: retSegIds});
		return {points: retSeg, trackPointIds: retSegIds};
	}
	
	var i = trackPoints.length;
	
	while (i > 0){
		i--;
		if(findMatchInTrackPoints(trackPoints[i].p1) > 2 && findMatchIn(switches, trackPoints[i].p1)){
			switches.push(trackPoints[i].p1);
		}
		else if(findMatchInTrackPoints(trackPoints[i].p1) == 1 && findMatchIn(ends, trackPoints[i].p1)){
			ends.push(trackPoints[i].p1);
		}
		
		if(findMatchInTrackPoints(trackPoints[i].p3) > 2 && findMatchIn(switches, trackPoints[i].p3)){
			switches.push(trackPoints[i].p3);
		}
		else if(findMatchInTrackPoints(trackPoints[i].p3) == 1 && findMatchIn(ends, trackPoints[i].p3)){
			ends.push(trackPoints[i].p3);
		}
	}
	
	console.log('switches',switches);
	console.log('ends',ends);

	i = switches.length;
	while(i > 0){
		i--;
		tempSections = [];
		tempSectionsTPIds = [];
		tempSections.push(switches[i]);
		j = trackPoints.length;
		while(j > 0 && tempSections.length < 15){
			j--;
			if (equalXZ(switches[i], trackPoints[j].p1) == 1) {
				if(findSegmentInSection(j)){
					trackSections.shift(findSegmentInSection(j),1);
				}
				trackSections.push(buildASectionFromSegment(j, 1));
			}
			else if (equalXZ(switches[i], trackPoints[j].p3) == 1) {
				if(findSegmentInSection(j)){
					trackSections.shift(findSegmentInSection(j),1);
				}
				trackSections.push(buildASectionFromSegment(j, 0));
			}
		}
	}
	console.log('sections - predata',trackSections)*/
}

buildSections();
</script>


check if on switch
	check if new switch
		split seg
	else add seg to switch
else check if added to section

check if new section

